\documentclass[answers]{exam}

\input{premable.tex}

\title{算法与复杂性 \quad 作业九}

\author{516021910528 - SHEN Jiamin}
\date{\today}

\begin{document}

\maketitle

\section{0413}\label{sec:0413}
\begin{questions}\label{qset:0413}

    \question 对于给定的二叉树，求其最小深度，即从根节点到最近的叶子的距离。

    \begin{solution}
        广度优先搜索最先到达的叶子节点有最小的深度。

        最差情况下遍历了整棵树，时间复杂度为$O(N)$，其中$N$为节点的数量。

        \begin{algorithm}[H]
            \caption{求二叉树的最小深度} \label{alg:0413:01}
            \begin{algorithmic}[1]
                \Require {$root$（给定二叉树的根节点）}
                \Ensure {$mindepth$（二叉树中的最小深度）}
                \State $q \gets \Call{Queue.Init}{}$
                \State $\Call{Queue.Push}{q, \langle root, 0 \rangle}$
                \While {$\neg \Call{Queue.isEmpty}{q}$}
                \State $\langle current, depth \rangle \gets \Call{Queue.Pop}{q}$
                \If {$current.isLeaf$} \Comment{当前节点是叶子节点}
                \State \Return $depth$ \Comment{BFS最先到达的叶子节点有最小的深度}
                \EndIf

                \If {$current.left$} \Comment{左子树入队}
                \State $\Call{Queue.Push}{q, \langle current.left, depth+1 \rangle}$
                \EndIf

                \If {$current.right$} \Comment{右子树入队}
                \State $\Call{Queue.Push}{q, \langle current.right, depth+1 \rangle}$
                \EndIf
                \EndWhile
            \end{algorithmic}
        \end{algorithm}
    \end{solution}

    \newpage

    \question 设$G$是有向非循环图，其所有路径最多含$k$条边。
    设计线性时间算法，将所有顶点分为$k+1$组，每一组中任意两个点之间不存在路径。

    \begin{solution}
        DAG中一定存在入度为$0$的节点，且一定存在出度为$0$的节点，最长路径出现在入度为$0$的节点和出度为$0$的节点之间（否则可以沿两端点继续扩展路径，得到更长的路径）。

        按照拓扑排序的顺序，删除DAG中入度为$0$的节点后，上述最长路径的长度一定减小$1$。
        且在拓扑排序中同一批被移除的节点之间一定不存在路径（否则删除起点时，终点的入度一定不为0）。
        因此可按照拓扑排序中删除节点的批次将所有节点分为$k+1$组，且每一组中任意两个节点之间不存在路径。

        当图以出边邻接表给出时，算法的时间复杂度为$O(|V| + |E|)$。

        \begin{algorithm}[H]
            \caption{拓扑分组} \label{alg:0413:02}
            \begin{algorithmic}[1]
                \Require {$G=(V,E)$（给定DAG的出边表）}
                \Ensure {$vtop\left[1 \dots |V|\right], bnd$（$vtop\left[bnd[i] \dots bnd[i+1]\right]$中的节点不存在路径）}

                \State $vtop \gets \Call{Vector.Init}{}, bnd \gets \Call{Vector.Init}{}$

                \State $indeg \gets \Call{Array.Init}{$|V|, 0$}$  \Comment{构造入度表}
                \For {$(v,w)$ in $E$}
                \State $indeg[w] \gets indeg[w] + 1$
                \EndFor

                \For {$v$ in $V$ where $indeg[v] = 0$} \Comment{找到入度为$0$的节点}
                \State $\Call{Vector.PushBack}{vtop, v}$
                \EndFor

                \Statex \Comment{拓扑排序}
                \State $inf \gets 1, \Call{Vector.PushBack}{bnd, inf}$
                \State $sup \gets \Call{Vector.size}{vtop}, \Call{Vector.PushBack}{bnd, sup}$
                \While {$\Call{Vector.size}{vtop} < |V|$}
                \For{$idx \gets inf$ to $sup$} \Comment{对于每一个上一阶段找到的入度为$0$的节点}
                \For {$(v, w)$ in $E$ where $v = vtop[idx]$} \Comment{找到其后继节点}
                \State $indeg[w] \gets indeg[w] - 1$ \Comment{减后继节点的入度}
                \If{$indeg[w] = 0$} \Comment{并检查是否减到了$0$}
                \State $\Call{Vector.PushBack}{vtop, w}$
                \EndIf
                \EndFor
                \EndFor
                \State $inf \gets sup + 1$
                \State $sup \gets \Call{Vector.size}{vtop}, \Call{Vector.PushBack}{bnd, sup}$
                \EndWhile
            \end{algorithmic}
        \end{algorithm}

    \end{solution}

    \question 给定连通无向图$G$以及3条边$a,b,c$，在线性时间内判断$G$中是否存在一个包含$a$和$b$但不含$c$的闭链。

    \begin{solution}
        删除边$c$，在剩余的图中判断是否存在包含$a,b$的回路。

        在剩余的无向图中划分双连通分支（线性时间），若$a,b$在同一个双连通分支里，则存在一条包含$a,b$但不包含$c$的回路。
    \end{solution}

\end{questions}

% \newpage %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{0416}\label{sec:0416}
\begin{questions}\label{qset:0416}

    \question 求$n \times m$棋盘上任意两点之间马能够走的最短路径长度

    \begin{solution}
        构造图$G=(E,V)$\begin{itemize}
            \item $E$为棋盘上所有格点
            \item 若“马”能从棋盘上的点$v$经过一步走到$w$，则$(v,w) \in V$
        \end{itemize}

        对上图进行广度优先搜索即可找出最短路径长度。
        进一步地，构图和广度优先搜索可以同时进行。

    \end{solution}

    \question 设计线性时间算法求树的最大匹配

    \begin{solution}
        树中一个非叶子节点连向其子节点的若干条边及连向其父节点的边中，至多只有一条边属于匹配。

        记函数$f(v, b)$为以$v$为根节点的子树中最大匹配的边数，其中$b$为布尔值\begin{itemize}
            \item 当$b=1$时，存在一条与$v$直接相连的边在最大匹配中
            \item 当$b=0$时，与$v$直接相连的边都不在最大匹配中
        \end{itemize}

        对于树的根节点$v$，假设其有3个子节点$w_1,w_2,w_3$并有相应地与之相连的三条边$e_1, e_2, e_3$，则
        \[
            f(v) = \max_b {f(v,b)} = \max \begin{cases}
                f(w_1,1) + f(w_2,1) + f(w_3,1) & (b=0) \\
                \max \begin{cases}
                    f(w_1,0) + f(w_2,1) + f(w_3,1) + 1 \\
                    f(w_1,1) + f(w_2,0) + f(w_3,1) + 1 \\
                    f(w_1,1) + f(w_2,1) + f(w_3,0) + 1 \\
                \end{cases} & (b=1)
            \end{cases}
        \]

        观察可知对于每一棵子树，只需考察$b=1$和$b=0$两种情况；且$b=0$当且仅当对于其所有子树$b=1$。
        当$v$是叶子节点时，$f(v) = f(v) = 0$；
        所以当$v$的所有子节点都是叶子节点时，$f(v) = f(v, 1) = 1$。
        对树做一次后序遍历，并按照上述规则计算出所有节点的$f(v,0)和f(v,1)$即可。
        
        每个节点被访问两次（下行入栈一次，上行出栈一次）；计算$f$时比较的情况数等于该节点的度数，所有节点的度数和为$2|E|$。
        所以算法的时间复杂度为$O(|V|+|E|)$
    \end{solution}

    \question 无向图$G$的顶点覆盖是指顶点集合$U$，$G$中每条边都至少有一个顶点在此集合中。
    设计线性时间算法为树寻找一个顶点覆盖，并且使该点集的规模尽量小。

    \begin{solution}
        初始化所有结点的度。
        对于所有度数为$1$的节点，首先标记其相邻的点都在$U$中，然后删除与U中的点直接相邻的所有边。
        重复上述步骤，直至所有边都被删除。

    \end{solution}

\end{questions}
\end{document}